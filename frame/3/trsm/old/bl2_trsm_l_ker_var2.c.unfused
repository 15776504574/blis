/*
   libblis
   An object-based infrastructure for developing high-performance
   dense linear algebra libraries.

   Copyright (C) 2013, The University of Texas

   libblis is free software; you can redistribute it and/or modify
   it under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation; either version 2.1 of
   the License, or (at your option) any later version.

   libblis is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with libblis; if you did not receive a copy, see
   http://www.gnu.org/licenses/.

   For more information, please contact us at blis@cs.utexas.edu or
   send mail to:

   Field G. Van Zee and/or
   Robert A. van de Geijn
   The University of Texas at Austin
   Institute for Computational Engineering and Science
   1 University Station D9500
   Austin TX 78712
*/

#include "blis2.h"

#define FUNCPTR_T gemm_fp

typedef void (*FUNCPTR_T)(
                           doff_t  diagoffa,
                           dim_t   m,
                           dim_t   n,
                           dim_t   k,
                           void*   a, inc_t rs_a, inc_t cs_a, inc_t ps_a,
                           void*   b, inc_t rs_b, inc_t cs_b, inc_t ps_b,
                           void*   c, inc_t rs_c, inc_t cs_c
                         );

static FUNCPTR_T GENARRAY(ftypes,trsm_l_ker_var2);


void bl2_trsm_l_ker_var2( obj_t*  alpha,
                          obj_t*  a,
                          obj_t*  b,
                          obj_t*  beta,
                          obj_t*  c,
                          trsm_t* cntl )
{
	num_t     dt_exec   = bl2_obj_execution_datatype( *c );

	doff_t    diagoffa  = bl2_obj_diag_offset( *a );

	dim_t     m         = bl2_obj_length( *c );
	dim_t     n         = bl2_obj_width( *c );
	dim_t     k         = bl2_obj_width( *a );

	void*     buf_a     = bl2_obj_buffer_at_off( *a );
	inc_t     rs_a      = bl2_obj_row_stride( *a );
	inc_t     cs_a      = bl2_obj_col_stride( *a );
	inc_t     ps_a      = bl2_obj_panel_stride( *a );

	void*     buf_b     = bl2_obj_buffer_at_off( *b );
	inc_t     rs_b      = bl2_obj_row_stride( *b );
	inc_t     cs_b      = bl2_obj_col_stride( *b );
	inc_t     ps_b      = bl2_obj_panel_stride( *b );

	void*     buf_c     = bl2_obj_buffer_at_off( *c );
	inc_t     rs_c      = bl2_obj_row_stride( *c );
	inc_t     cs_c      = bl2_obj_col_stride( *c );

	FUNCPTR_T f;

/*
	// Handle the special case where c and a are complex and b is real.
	// Note that this is the ONLY case allowed by the inner kernel whereby
	// the datatypes of a and b differ. In this situation, the execution
	// datatype is real, so we need to inflate (by a factor of two):
	//  - the m dimension,
	//  - the column stride of c,
	//  - the column stride (ie: the panel length) of a, and
	//  - the panel stride of a.
	if ( bl2_obj_is_complex( *a ) && bl2_obj_is_real( *b ) )
	{
		m    *= 2;
		cs_c *= 2;
		cs_a *= 2;
		ps_a *= 2;
	}
*/

	// Index into the type combination array to extract the correct
	// function pointer.
	f = ftypes[dt_exec];

	// Invoke the function.
	f( diagoffa,
	   m,
	   n,
	   k,
	   buf_a, rs_a, cs_a, ps_a,
	   buf_b, rs_b, cs_b, ps_b,
	   buf_c, rs_c, cs_c );
}


#undef  GENTFUNC
#define GENTFUNC( ctype, ch, opname, varname ) \
\
void PASTEMAC(ch,varname)( \
                           doff_t  diagoffa, \
                           dim_t   m, \
                           dim_t   n, \
                           dim_t   k, \
                           void*   a, inc_t rs_a, inc_t cs_a, inc_t ps_a, \
                           void*   b, inc_t rs_b, inc_t cs_b, inc_t ps_b, \
                           void*   c, inc_t rs_c, inc_t cs_c \
                         ) \
{ \
	/* Temporary buffer for duplicating elements of B. */ \
	ctype           bd[ PASTEMAC2(ch,varname,_kc) * \
	                    PASTEMAC2(ch,varname,_nr) * \
	                    PASTEMAC2(ch,varname,_ndup) ]; \
\
	/* Temporary C buffer for edge cases. */ \
	ctype           ct[ PASTEMAC2(ch,varname,_mr) * \
	                    PASTEMAC2(ch,varname,_nr) ]; \
	const inc_t     rs_ct = 1; \
	const inc_t     cs_ct = PASTEMAC2(ch,varname,_mr); \
\
	/* Alias constants to shorter names. */ \
	const dim_t     MR        = PASTEMAC2(ch,varname,_mr); \
	const dim_t     NR        = PASTEMAC2(ch,varname,_nr); \
	const dim_t     NDUP      = PASTEMAC2(ch,varname,_ndup); \
\
	ctype* restrict one       = PASTEMAC(ch,1); \
	ctype* restrict zero      = PASTEMAC(ch,0); \
	ctype* restrict minus_one = PASTEMAC(ch,m1); \
	ctype* restrict a_cast    = a; \
	ctype* restrict b_cast    = b; \
	ctype* restrict c_cast    = c; \
	ctype* restrict a1; \
	ctype* restrict b1; \
	ctype* restrict c1; \
	ctype* restrict c11; \
	ctype* restrict b11; \
	ctype* restrict a10; \
	ctype* restrict a11; \
	ctype* restrict bd01; \
	ctype* restrict bd11; \
	ctype* restrict bd_i; \
\
	doff_t          diagoffa_i; \
	dim_t           m_iter, m_left; \
	dim_t           n_iter, n_left; \
	dim_t           m_cur; \
	dim_t           n_cur; \
	dim_t           k_ndup; \
	dim_t           k_a1011; \
	dim_t           k_a10; \
	dim_t           off_a1011, off_b11; \
	dim_t           i, j; \
	dim_t           rstep_a; \
	dim_t           rstep_b, cstep_b; \
	dim_t           rstep_c, cstep_c; \
\
	/*
	   Assumptions/assertions:
         rs_a == 1
	     cs_a == GEMM_MR
	     ps_a == stride to next row panel of A
         rs_b == GEMM_NR
	     cs_b == 1
	     ps_b == stride to next column panel of B
         rs_c == (no assumptions)
	     cs_c == (no assumptions)
	*/ \
\
\
	if ( bl2_zero_dim3( m, n, k ) ) return; \
\
	/* Safeguard: If matrix A is above the diagonal, it is implicitly zero.
	   So we do nothing. */ \
	if ( bl2_is_strictly_above_diag_n( diagoffa, m, k ) ) return; \
\
	/* The first thing we do is check the k dimension, which needs to be
	   a multiple of MR. If k isn't a multiple of MR, we adjust it higher.
	   This allows us to use a single micro-kernel, which performs an
	   MR x MR triangular solve, even for cases when k isn't actually a
	   multiple of MR. The key is that when A was packed, its edges were
	   first zero padded, and further, the panel that stores the bottom-
	   right corner of the matrix has its diagonal that extendeds into
	   the zero padded region as identity. This allows the trsm of that
	   bottom-right panel to proceed without producing any infs or NaNs
	   or any other numerical funny business that would infect the "good"
	   values of the corresponding block of B. */ \
	if ( k % MR != 0 ) k += MR - ( k % MR ); \
\
	/* If the diagonal offset is negative, adjust the pointer to C and
	   treat this case as if the diagonal offset were zero. Note that
	   we don't need to adjust the pointer to A since packm would have
	   simply skipped over the panels that were not stored. */ \
	if ( diagoffa < 0 ) \
	{ \
		i        = -diagoffa; \
		m        = m - i; \
		diagoffa = 0; \
		c_cast   = c_cast + (i  )*rs_c; \
	} \
\
	/* Compute number of primary and leftover components of the m and n
       dimensions. */ \
	n_iter  = n / NR; \
	n_left  = n % NR; \
\
	m_iter  = m / MR; \
	m_left  = m % MR; \
\
	if ( n_left ) ++n_iter; \
	if ( m_left ) ++m_iter; \
\
	k_a1011 = bl2_min( k, diagoffa + m ); \
	k_ndup  = k_a1011 * NDUP; \
\
	off_b11 = diagoffa; \
\
	rstep_a = k * MR; \
\
	rstep_b = NR * MR; \
	cstep_b = ps_b; \
\
	rstep_c = rs_c * MR; \
	cstep_c = cs_c * NR; \
\
	b1 = b_cast; \
	c1 = c_cast; \
\
	/* Loop over the n dimension (NR columns at a time). */ \
	for ( j = 0; j < n_iter; ++j ) \
	{ \
		a1  = a_cast; \
		c11 = c1; \
		b11 = b1 + (off_b11  )*NR; \
\
		n_cur = ( bl2_is_not_edge_f( j, n_iter, n_left ) ? NR : n_left ); \
\
		/* Copy the current iteration's NR columns of B to a local buffer
		   with each value duplicated. */ \
		PASTEMAC2(ch,varname,_dupl)( k_ndup, b1, bd ); \
\
		/* Loop over the m dimension (MR rows at a time). */ \
		for ( i = 0; i < m_iter; ++i ) \
		{ \
			diagoffa_i = diagoffa + ( doff_t )i*MR; \
\
			m_cur = ( bl2_is_not_edge_f( i, m_iter, m_left ) ? MR : m_left ); \
\
			/* If the current panel of A intersects the diagonal, use a
			   special micro-kernel that performs a fused gemm and trsm.
			   If the current panel of A resides below the diagonal, use a
			   a regular gemm micro-kernel. Otherwise, if it is above the
			   diagonal, it was not packed (because it is implicitly zero)
			   and so we do nothing. */ \
			if ( bl2_intersects_diag_n( diagoffa_i, MR, k ) ) \
			{ \
				/* Determine the offset to the beginning of the panel that
				   was packed so we can index into the corresponding location
				   in bd. Then compute the length of that panel. */ \
				off_a1011 = 0; \
				k_a1011   = bl2_min( k, diagoffa_i + m_cur ); \
				k_a10     = k_a1011 - m_cur; \
\
				bd_i = bd + off_a1011 * NR * NDUP; \
\
				/* Compute the addresses of the A10 panel and triangular
				   block A11, and the corresponding panel Bd01 and block
				   Bd11. */ \
				a10  = a1; \
				a11  = a1   + k_a10 * MR; \
				bd01 = bd_i; \
				bd11 = bd_i + k_a10 * NR * NDUP; \
\
				/* Handle interior and edge cases separately. */ \
				if ( m_cur == MR && n_cur == NR ) \
				{ \
					/* Invoke the fused gemm/trsm micro-kernel. */ \
					PASTEMAC2(ch,varname,_gemm_ukr)( k_a10, \
					                                 minus_one, \
					                                 a10, \
					                                 bd01, \
					                                 one, \
					                                 b11, rs_b, cs_b ); \
					PASTEMAC2(ch,varname,_trsmonly_ukr)( k_a10, \
					                                 a11, \
					                                 bd11, \
					                                 b11, \
					                                 c11, rs_c, cs_c ); \
				} \
				else \
				{ \
					/* Invoke the fused gemm/trsm micro-kernel. */ \
					PASTEMAC2(ch,varname,_trsm_ukr)( k_a10, \
					                                 a10, \
					                                 a11, \
					                                 bd01, \
					                                 bd11, \
					                                 b11, \
					                                 ct, rs_ct, cs_ct ); \
\
					/* Copy the result to the bottom edge of C. */ \
					PASTEMAC2(ch,ch,copys_mxn)( m_cur, n_cur, \
					                            ct,  rs_ct, cs_ct, \
					                            c11, rs_c,  cs_c ); \
				} \
\
				a1 += k_a1011 * MR; \
			} \
			else if ( bl2_is_strictly_below_diag_n( diagoffa_i, MR, k ) ) \
			{ \
				/* Handle interior and edge cases separately. */ \
				if ( m_cur == MR && n_cur == NR ) \
				{ \
					/* Invoke the gemm micro-kernel. */ \
					PASTEMAC2(ch,varname,_gemm_ukr)( k, \
					                                 minus_one, \
					                                 a1, \
					                                 bd, \
					                                 one, \
					                                 c11, rs_c, cs_c ); \
				} \
				else \
				{ \
					/* Invoke the gemm micro-kernel. */ \
					PASTEMAC2(ch,varname,_gemm_ukr)( k, \
					                                 minus_one, \
					                                 a1, \
					                                 bd, \
					                                 zero, \
					                                 ct, rs_ct, cs_ct ); \
\
					/* Add the result to the edge of C. */ \
					PASTEMAC2(ch,ch,adds_mxn)( m_cur, n_cur, \
					                           ct,  rs_ct, cs_ct, \
					                           c11, rs_c,  cs_c ); \
				} \
\
				a1 += rstep_a; \
			} \
\
			b11  += rstep_b; \
			c11  += rstep_c; \
		} \
\
		b1 += cstep_b; \
		c1 += cstep_c; \
	} \
}

INSERT_GENTFUNC_BASIC( trsm, trsm_l_ker_var2 )

