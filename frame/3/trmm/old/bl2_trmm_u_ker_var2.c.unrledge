/*
   libblis
   An object-based infrastructure for developing high-performance
   dense linear algebra libraries.

   Copyright (C) 2012, The University of Texas

   libblis is free software; you can redistribute it and/or modify
   it under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation; either version 2.1 of
   the License, or (at your option) any later version.

   libblis is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with libblis; if you did not receive a copy, see
   http://www.gnu.org/licenses/.

   For more information, please contact us at blis@cs.utexas.edu or
   send mail to:

   Field G. Van Zee and/or
   Robert A. van de Geijn
   The University of Texas at Austin
   Institute for Computational Engineering and Science
   1 University Station D9500
   Austin TX 78712
*/

#include "blis2.h"

#define FUNCPTR_T gemm_fp

typedef void (*FUNCPTR_T)(
                           doff_t  diagoffa,
                           dim_t   m,
                           dim_t   n,
                           dim_t   k,
                           void*   a, inc_t rs_a, inc_t cs_a, inc_t ps_a,
                           void*   b, inc_t rs_b, inc_t cs_b, inc_t ps_b,
                           void*   beta,
                           void*   c, inc_t rs_c, inc_t cs_c
                         );

static FUNCPTR_T GENARRAY(ftypes,trmm_u_ker_var2);


void bl2_trmm_u_ker_var2( obj_t*  alpha,
                          obj_t*  a,
                          obj_t*  b,
                          obj_t*  beta,
                          obj_t*  c,
                          trmm_t* cntl )
{
	num_t     dt_exec   = bl2_obj_execution_datatype( *c );

	doff_t    diagoffa  = bl2_obj_diag_offset( *a );

	dim_t     m         = bl2_obj_length( *c );
	dim_t     n         = bl2_obj_width( *c );
	dim_t     k         = bl2_obj_width( *a );

	void*     buf_a     = bl2_obj_buffer_at_off( *a );
	inc_t     rs_a      = bl2_obj_row_stride( *a );
	inc_t     cs_a      = bl2_obj_col_stride( *a );
	inc_t     ps_a      = bl2_obj_panel_stride( *a );

	void*     buf_b     = bl2_obj_buffer_at_off( *b );
	inc_t     rs_b      = bl2_obj_row_stride( *b );
	inc_t     cs_b      = bl2_obj_col_stride( *b );
	inc_t     ps_b      = bl2_obj_panel_stride( *b );

	void*     buf_c     = bl2_obj_buffer_at_off( *c );
	inc_t     rs_c      = bl2_obj_row_stride( *c );
	inc_t     cs_c      = bl2_obj_col_stride( *c );

	num_t     dt_beta;
	void*     buf_beta;

	FUNCPTR_T f;

/*
	// Handle the special case where c and a are complex and b is real.
	// Note that this is the ONLY case allowed by the inner kernel whereby
	// the datatypes of a and b differ. In this situation, the execution
	// datatype is real, so we need to inflate (by a factor of two):
	//  - the m dimension,
	//  - the column stride of c,
	//  - the column stride (ie: the panel length) of a, and
	//  - the panel stride of a.
	if ( bl2_obj_is_complex( *a ) && bl2_obj_is_real( *b ) )
	{
		m    *= 2;
		cs_c *= 2;
		cs_a *= 2;
		ps_a *= 2;
	}
*/

	// If beta is a scalar constant, use dt_exec to extract the address of the
	// corresponding constant value; otherwise, use the datatype encoded
	// within the beta object and extract the buffer at the beta offset.
	// (If beta is complex with a zero imaginary component, that is reflected
	// in dt_beta. However, that functionality is not used here.)
	bl2_set_scalar_dt_buffer( beta, dt_exec, dt_beta, buf_beta );

	// Index into the type combination array to extract the correct
	// function pointer.
	f = ftypes[dt_exec];

	// Invoke the function.
	f( diagoffa,
	   m,
	   n,
	   k,
	   buf_a, rs_a, cs_a, ps_a,
	   buf_b, rs_b, cs_b, ps_b,
	   buf_beta,
	   buf_c, rs_c, cs_c );
}


#undef  GENTFUNC
#define GENTFUNC( ctype, ch, opname, varname ) \
\
void PASTEMAC(ch,varname)( \
                           doff_t  diagoffa, \
                           dim_t   m, \
                           dim_t   n, \
                           dim_t   k, \
                           void*   a, inc_t rs_a, inc_t cs_a, inc_t ps_a, \
                           void*   b, inc_t rs_b, inc_t cs_b, inc_t ps_b, \
                           void*   beta, \
                           void*   c, inc_t rs_c, inc_t cs_c \
                         ) \
{ \
	/* Temporary buffer for duplicating elements of B. */ \
	ctype           bd[ PASTEMAC2(ch,varname,_kc) * \
	                    PASTEMAC2(ch,varname,_nr) * \
	                    PASTEMAC2(ch,varname,_ndup) ]; \
\
	/* Temporary C buffer for edge cases. */ \
	ctype           ct[ PASTEMAC2(ch,varname,_mr) * \
	                    PASTEMAC2(ch,varname,_nr) ]; \
	const inc_t     rs_ct  = 1; \
	const inc_t     cs_ct  = PASTEMAC2(ch,varname,_mr); \
\
	/* Alias some constants to shorter names. */ \
	const dim_t     MR     = PASTEMAC2(ch,varname,_mr); \
	const dim_t     NR     = PASTEMAC2(ch,varname,_nr); \
	const dim_t     NDUP   = PASTEMAC2(ch,varname,_ndup); \
\
	ctype* restrict one    = PASTEMAC(ch,1); \
	ctype* restrict a_cast = a; \
	ctype* restrict b_cast = b; \
	ctype* restrict c_cast = c; \
	ctype* restrict a1; \
	ctype* restrict b1; \
	ctype* restrict c1; \
	ctype* restrict c11; \
	ctype* restrict bd_i; \
\
	doff_t          diagoffa_i; \
	dim_t           m_iter, m_left; \
	dim_t           n_iter, n_left; \
	dim_t           k_ndup; \
	dim_t           k_a1011; \
	dim_t           off_a1011; \
	dim_t           i, j; \
	inc_t           rstep_a; \
	inc_t           cstep_b; \
	inc_t           rstep_c, cstep_c; \
\
	/*
	   Assumptions/assertions:
         rs_a == 1
	     cs_a == GEMM_MR
	     ps_a == stride to next row panel of A
         rs_b == GEMM_NR
	     cs_b == 1
	     ps_b == stride to next column panel of B
         rs_c == (no assumptions)
	     cs_c == (no assumptions)
	*/ \
\
	if ( bl2_zero_dim3( m, n, k ) ) return; \
\
	/* Safeguard: If matrix A is below the diagonal, it is implicitly zero.
	   So we do nothing. */ \
	if ( bl2_is_strictly_below_diag_n( diagoffa, m, k ) ) return; \
\
	/* If the diagonal offset is positive, adjust the pointer to B and
	   treat this case as if the diagonal offset were zero. Note that
	   we don't need to adjust the pointer to A since packm would have
	   simply skipped over the regions that were not stored. */ \
	if ( diagoffa > 0 ) \
	{ \
		j        = diagoffa; \
		n        = n - j; \
		diagoffa = 0; \
		b_cast   = b_cast + (j  )*rs_b; \
	} \
\
	/* Compute number of primary and leftover components of the m and n
	   dimensions. */ \
	n_iter = n / NR; \
	n_left = n % NR; \
\
	m_iter = m / MR; \
	m_left = m % MR; \
\
	off_a1011 = bl2_max( diagoffa, 0 ); \
	k_a1011   = k - off_a1011; \
	k_ndup    = k_a1011 * NDUP; \
\
	rstep_a = k * MR; \
\
	cstep_b = ps_b; \
\
	rstep_c = MR * rs_c; \
	cstep_c = NR * cs_c; \
\
	b1  = b_cast; \
	c1  = c_cast; \
\
	for ( j = 0; j < n_iter; ++j ) \
	{ \
		a1  = a_cast; \
		c11 = c1; \
\
		/* Copy the current iteration's NR columns of B to a local buffer
		   with each value duplicated. */ \
		PASTEMAC2(ch,varname,_dupl)( k_ndup, b1, bd ); \
\
		/* Interior loop. */ \
		for ( i = 0; i < m_iter; ++i ) \
		{ \
			diagoffa_i = diagoffa + ( doff_t )i*MR; \
\
			if ( bl2_intersects_diag_n( diagoffa_i, MR, k ) ) \
			{ \
				/* Determine the offset to the beginning of the panel that
				   was packed so we can index into the corresponding location
				   in bd. Then compute the length of that panel. */ \
				off_a1011 = bl2_max( diagoffa_i, 0 ); \
				k_a1011   = k - off_a1011; \
\
				bd_i = bd + off_a1011 * NR * NDUP; \
\
				/* Invoke the gemm micro-kernel. */ \
				PASTEMAC2(ch,varname,_ukr)( k_a1011, \
				                            one, \
				                            a1, \
				                            bd_i, \
				                            beta, \
				                            c11, rs_c, cs_c ); \
\
				a1 += k_a1011 * MR; \
			} \
			else if ( bl2_is_strictly_above_diag_n( diagoffa_i, MR, k ) ) \
			{ \
				/* Invoke the gemm micro-kernel. */ \
				PASTEMAC2(ch,varname,_ukr)( k, \
				                            one, \
				                            a1, \
				                            bd, \
				                            one, \
				                            c11, rs_c, cs_c ); \
\
				a1 += rstep_a; \
			} \
\
			c11 += rstep_c; \
		} \
\
		/* Bottom edge handling. */ \
		if ( m_left ) \
		{ \
			diagoffa_i = diagoffa + ( doff_t )i*MR; \
\
			if ( bl2_intersects_diag_n( diagoffa_i, m_left, k ) ) \
			{ \
				/* Determine the offset to the beginning of the panel that
				   was packed so we can index into the corresponding location
				   in bd. Then compute the length of that panel. */ \
				off_a1011 = bl2_max( diagoffa_i, 0 ); \
				k_a1011   = k - off_a1011; \
\
				bd_i = bd + off_a1011 * NR * NDUP; \
\
				/* Copy edge elements of C to the temporary buffer. */ \
				PASTEMAC2(ch,ch,copys_mxn)( m_left, NR, \
				                            c11, rs_c,  cs_c, \
				                            ct,  rs_ct, cs_ct ); \
\
				/* Invoke the gemm micro-kernel. */ \
				PASTEMAC2(ch,varname,_ukr)( k_a1011, \
				                            one, \
				                            a1, \
				                            bd_i, \
				                            beta, \
				                            ct, rs_ct, cs_ct ); \
\
				/* Copy the result to the bottom edge of C. */ \
				PASTEMAC2(ch,ch,copys_mxn)( m_left, NR, \
				                            ct,  rs_ct, cs_ct, \
				                            c11, rs_c,  cs_c ); \
			} \
			else if ( bl2_is_strictly_above_diag_n( diagoffa_i, m_left, k ) ) \
			{ \
				/* Copy edge elements of C to the temporary buffer. */ \
				PASTEMAC2(ch,ch,copys_mxn)( m_left, NR, \
				                            c11, rs_c,  cs_c, \
				                            ct,  rs_ct, cs_ct ); \
\
				/* Invoke the gemm micro-kernel. */ \
				PASTEMAC2(ch,varname,_ukr)( k, \
				                            one, \
				                            a1, \
				                            bd, \
				                            one, \
				                            ct, rs_ct, cs_ct ); \
\
				/* Copy the result to the bottom edge of C. */ \
				PASTEMAC2(ch,ch,copys_mxn)( m_left, NR, \
				                            ct,  rs_ct, cs_ct, \
				                            c11, rs_c,  cs_c ); \
			} \
		} \
\
		b1 += cstep_b; \
		c1 += cstep_c; \
	} \
\
	if ( n_left ) \
	{ \
		a1  = a_cast; \
		c11 = c1; \
\
		/* Copy the n_left (+ padding) columns of B to a local buffer
		   with each value duplicated. */ \
		PASTEMAC2(ch,varname,_dupl)( k_ndup, b1, bd ); \
\
		/* Right edge loop. */ \
		for ( i = 0; i < m_iter; ++i ) \
		{ \
			diagoffa_i = diagoffa + ( doff_t )i*MR; \
\
			if ( bl2_intersects_diag_n( diagoffa_i, MR, k ) ) \
			{ \
				/* Determine the offset to the beginning of the panel that
				   was packed so we can index into the corresponding location
				   in bd. Then compute the length of that panel. */ \
				off_a1011 = bl2_max( diagoffa_i, 0 ); \
				k_a1011   = k - off_a1011; \
\
				bd_i = bd + off_a1011 * NR * NDUP; \
\
				/* Copy edge elements of C to the temporary buffer. */ \
				PASTEMAC2(ch,ch,copys_mxn)( MR, n_left, \
				                            c11, rs_c,  cs_c, \
				                            ct,  rs_ct, cs_ct ); \
\
				/* Invoke the gemm micro-kernel. */ \
				PASTEMAC2(ch,varname,_ukr)( k_a1011, \
				                            one, \
				                            a1, \
				                            bd_i, \
				                            beta, \
				                            ct, rs_ct, cs_ct ); \
\
				/* Copy the result to the bottom edge of C. */ \
				PASTEMAC2(ch,ch,copys_mxn)( MR, n_left, \
				                            ct,  rs_ct, cs_ct, \
				                            c11, rs_c,  cs_c ); \
\
				a1 += k_a1011 * MR; \
			} \
			else if ( bl2_is_strictly_above_diag_n( diagoffa_i, MR, k ) ) \
			{ \
				/* Copy edge elements of C to the temporary buffer. */ \
				PASTEMAC2(ch,ch,copys_mxn)( MR, n_left, \
				                            c11, rs_c,  cs_c, \
				                            ct,  rs_ct, cs_ct ); \
\
				/* Invoke the gemm micro-kernel. */ \
				PASTEMAC2(ch,varname,_ukr)( k, \
				                            one, \
				                            a1, \
				                            bd, \
				                            one, \
				                            ct, rs_ct, cs_ct ); \
\
				/* Copy the result to the bottom edge of C. */ \
				PASTEMAC2(ch,ch,copys_mxn)( MR, n_left, \
				                            ct,  rs_ct, cs_ct, \
				                            c11, rs_c,  cs_c ); \
\
				a1 += rstep_a; \
			} \
\
			c11 += rstep_c; \
		} \
\
		/* Bottom-right corner handling. */ \
		if ( m_left ) \
		{ \
			diagoffa_i = diagoffa + ( doff_t )i*MR; \
\
			if ( bl2_intersects_diag_n( diagoffa_i, m_left, k ) ) \
			{ \
				/* Determine the offset to the beginning of the panel that
				   was packed so we can index into the corresponding location
				   in bd. Then compute the length of that panel. */ \
				off_a1011 = bl2_max( diagoffa_i, 0 ); \
				k_a1011   = k - off_a1011; \
\
				bd_i = bd + off_a1011 * NR * NDUP; \
\
				/* Copy edge elements of C to the temporary buffer. */ \
				PASTEMAC2(ch,ch,copys_mxn)( m_left, n_left, \
				                            c11, rs_c,  cs_c, \
				                            ct,  rs_ct, cs_ct ); \
\
				/* Invoke the gemm micro-kernel. */ \
				PASTEMAC2(ch,varname,_ukr)( k_a1011, \
				                            one, \
				                            a1, \
				                            bd_i, \
				                            beta, \
				                            ct, rs_ct, cs_ct ); \
\
				/* Copy the result to the bottom edge of C. */ \
				PASTEMAC2(ch,ch,copys_mxn)( m_left, n_left, \
				                            ct,  rs_ct, cs_ct, \
				                            c11, rs_c,  cs_c ); \
			} \
			else if ( bl2_is_strictly_above_diag_n( diagoffa_i, m_left, k ) ) \
			{ \
				/* Copy edge elements of C to the temporary buffer. */ \
				PASTEMAC2(ch,ch,copys_mxn)( m_left, n_left, \
				                            c11, rs_c,  cs_c, \
				                            ct,  rs_ct, cs_ct ); \
\
				/* Invoke the gemm micro-kernel. */ \
				PASTEMAC2(ch,varname,_ukr)( k, \
				                            one, \
				                            a1, \
				                            bd, \
				                            one, \
				                            ct, rs_ct, cs_ct ); \
\
				/* Copy the result to the bottom edge of C. */ \
				PASTEMAC2(ch,ch,copys_mxn)( m_left, n_left, \
				                            ct,  rs_ct, cs_ct, \
				                            c11, rs_c,  cs_c ); \
			} \
		} \
	} \
}

INSERT_GENTFUNC_BASIC( trmm, trmm_u_ker_var2 )

