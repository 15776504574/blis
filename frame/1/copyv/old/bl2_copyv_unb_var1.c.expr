/*
   libblis
   An object-based infrastructure for developing high-performance
   dense linear algebra libraries.

   Copyright (C) 2012, The University of Texas

   libblis is free software; you can redistribute it and/or modify
   it under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation; either version 2.1 of
   the License, or (at your option) any later version.

   libblis is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with libblis; if you did not receive a copy, see
   http://www.gnu.org/licenses/.

   For more information, please contact us at blis@cs.utexas.edu or
   send mail to:

   Field G. Van Zee and/or
   Robert A. van de Geijn
   The University of Texas at Austin
   Institute for Computational Engineering and Science
   1 University Station D9500
   Austin TX 78712
*/

#include "blis2.h"

#define FUNCPTR_T copyv_fp

typedef void (*FUNCPTR_T)(
                           conj_t conjx,
                           dim_t  n,
                           void*  x, inc_t incx,
                           void*  y, inc_t incy
                         );

// If some mixed datatype functions will not be compiled, we initialize
// the corresponding elements of the function array to NULL.
#ifdef BLIS_ENABLE_MIXED_PRECISION_SUPPORT
static FUNCPTR_T GENARRAY2_ALL(ftypes,copyv_unb_var1);
#else
#ifdef BLIS_ENABLE_MIXED_DOMAIN_SUPPORT
static FUNCPTR_T GENARRAY2_EXT(ftypes,copyv_unb_var1);
#else
static FUNCPTR_T GENARRAY2_MIN(ftypes,copyv_unb_var1);
#endif
#endif


void bl2_copyv_unb_var1( obj_t*  x,
                         obj_t*  y )
{
	num_t     dt_x      = bl2_obj_datatype( *x );
	num_t     dt_y      = bl2_obj_datatype( *y );

	conj_t    conjx     = bl2_obj_conj_status( *x );
	dim_t     n         = bl2_obj_vector_dim( *x );

	inc_t     inc_x     = bl2_obj_vector_inc( *x );
	void*     buf_x     = bl2_obj_buffer_at_off( *x );

	inc_t     inc_y     = bl2_obj_vector_inc( *y );
	void*     buf_y     = bl2_obj_buffer_at_off( *y );

	FUNCPTR_T f;

	// Index into the type combination array to extract the correct
	// function pointer.
	f = ftypes[dt_x][dt_y];

	// Invoke the function.
	f( conjx,
	   n,
	   buf_x, inc_x,
	   buf_y, inc_y );
}


#undef  GENTFUNC2
#define GENTFUNC2( ctype_x, ctype_y, chx, chy, opname, varname ) \
\
void PASTEMAC2(chx,chy,varname)( \
                                 conj_t conjx, \
                                 dim_t  n, \
                                 void*  x, inc_t incx, \
                                 void*  y, inc_t incy \
                               ) \
{ \
	ctype_x* x_cast = x; \
	ctype_y* y_cast = y; \
	ctype_x* chi1; \
	ctype_y* psi1; \
	dim_t    i; \
\
	if ( bl2_zero_dim1( n ) ) return; \
\
	chi1 = x_cast; \
	psi1 = y_cast; \
\
	if ( bl2_is_conj( conjx ) ) \
	{ \
		for ( i = 0; i < n; ++i ) \
		{ \
			PASTEMAC2(chx,chy,copyjs)( *chi1, *psi1 ); \
\
			chi1 += incx; \
			psi1 += incy; \
		} \
	} \
	else \
	{ \
		for ( i = 0; i < n; ++i ) \
		{ \
			PASTEMAC2(chx,chy,copys)( *chi1, *psi1 ); \
\
			chi1 += incx; \
			psi1 += incy; \
		} \
	} \
}

// Define the basic set of functions unconditionally, and then also some
// mixed datatype functions if requested.
//INSERT_GENTFUNC2_BASIC( copyv, copyv_unb_var1 )
GENTFUNC2( float,    float,    s, s, copyv, copyv_unb_var1 )
//GENTFUNC2( double,   double,   d, d, copyv, copyv_unb_var1 )
GENTFUNC2( scomplex, scomplex, c, c, copyv, copyv_unb_var1 )
GENTFUNC2( dcomplex, dcomplex, z, z, copyv, copyv_unb_var1 )

#ifdef BLIS_ENABLE_MIXED_DOMAIN_SUPPORT
INSERT_GENTFUNC2_MIX_D( copyv, copyv_unb_var1 )
#endif

#ifdef BLIS_ENABLE_MIXED_PRECISION_SUPPORT
INSERT_GENTFUNC2_MIX_P( copyv, copyv_unb_var1 )
#endif

void bl2_ddcopyv_unb_var1( 
                           conj_t conjx,
                           dim_t  n,
                           void*  x, inc_t incx,
                           void*  y, inc_t incy
                         )
{
	double* restrict x_cast = x;
	double* restrict y_cast = y;
	double* restrict chi1;
	double* restrict psi1;
	dim_t   i;

	//if ( bl2_zero_dim1( n ) ) return;

	if ( n == 2 && incx == 1 && incy == 1 )
	{
		*(y_cast + 0) = *(x_cast + 0);
		*(y_cast + 1) = *(x_cast + 1);
		return;
	}
	else if ( n == 4 && incx == 1 && incy == 1 )
	{
		*(y_cast + 0) = *(x_cast + 0);
		*(y_cast + 1) = *(x_cast + 1);
		*(y_cast + 2) = *(x_cast + 2);
		*(y_cast + 3) = *(x_cast + 3);
		return;
	}

	if ( incx == 1 &&
	     incy == 1 &&
	     (unsigned long)x % 16 == 0 &&
	     (unsigned long)y % 16 == 0 )
	{
		dim_t   n_iter = n / 4;
		dim_t   n_left = n % 4;


	__asm__ volatile
	(
		"movl     %2, %%eax              \n\t" // x
		"movl     %4, %%ebx              \n\t" // y
		"                                \n\t"
		"movl     %3, %%ecx              \n\t" // incx
		"movl     %5, %%edx              \n\t" // incy
		"                                \n\t"
		"sall     $4, %%ecx              \n\t" // 16*incx
		"sall     $4, %%edx              \n\t" // 16*incy
		"                                \n\t"
		"                                \n\t"
		"movl      %0, %%esi             \n\t"
		"testl  %%esi, %%esi             \n\t"
		"je     .CONSIDERKLEFT           \n\t"
		"                                \n\t"
		"                                \n\t"
		".LOOPKITER:                     \n\t"
		"                                \n\t"
		"movapd  (%%eax), %%xmm0         \n\t"
		"movapd  %%xmm0, (%%ebx)         \n\t"
		"                                \n\t"
		"movapd  (%%eax,%%ecx), %%xmm1   \n\t"
		"movapd  %%xmm1, (%%ebx,%%edx)   \n\t"
		"                                \n\t"
		"leal (%%eax,%%ecx,2), %%eax       \n\t"
		"leal (%%ebx,%%edx,2), %%ebx       \n\t"
		"                                \n\t"
		"                                \n\t"
		"decl  %%esi                     \n\t"
		"jne    .LOOPKITER               \n\t"
		"                                \n\t"
		"                                \n\t"
		"                                \n\t"
		".CONSIDERKLEFT:                 \n\t"
		"                                \n\t"
		"movl      %1, %%esi             \n\t"
		"testl  %%esi, %%esi             \n\t"
		"je     .DONE                    \n\t"
		"                                \n\t"
		"                                \n\t"
		"sarl     $1, %%ecx              \n\t" // 8*incx
		"sarl     $1, %%edx              \n\t" // 8*incy
		"                                \n\t"
		".LOOPKLEFT:                     \n\t"
		"                                \n\t"
		"movlpd  (%%eax), %%xmm0         \n\t"
		"movlpd  %%xmm0, (%%ebx)         \n\t"
		"                                \n\t"
		"addl %%ecx, %%eax               \n\t"
		"addl %%edx, %%ebx               \n\t"
		"                                \n\t"
		"decl   %%esi                    \n\t"
		"jne    .LOOPKLEFT               \n\t"
		"                                \n\t"
		"                                \n\t"
		".DONE:                          \n\t"
		"                                \n\t"

		: // output operands (none)
		: // input operands
		  "r" (n_iter),
		  "r" (n_left),
		  "m" (x),
		  "m" (incx),
		  "m" (y),
		  "m" (incy)
		: // register clobber list
		  "esi", "eax", "ebx", "ecx", "edx",
		  "xmm0", "xmm1", "xmm2", "xmm3",
		  "xmm4", "xmm5", "xmm6", "xmm7"
	);

	}
	else
	{
		chi1 = x;
		psi1 = y;

		for ( i = 0; i < n; ++i )
		{
			bl2_ddcopys( *chi1, *psi1 );

			chi1 += incx;
			psi1 += incy;
		}
	}

}

